{"version":3,"sources":["node_modules/Impetus/dist/impetus.js","src/wicket.js"],"names":["Impetus","require","log","msg","window","console","error","isTouchDevice","navigator","MaxTouchPoints","msMaxTouchPoints","forceRepaint","hatch","dataset","haspaint","style","display","offsetHeight","translateY","obj","val","Wicket","elm","options","hatches","document","querySelectorAll","impetus","scrollPoints","interval","isInit","scroller","index","scrollOffset","lastScrollTop","defaults","arguments","length","init","err","createScroller","fixHatches","calcScrollPoints","bindListeners","bindEvents","callChangeCallback","resume","createElement","position","width","body","appendChild","i","len","zIndex","oHeight","nHeight","push","unshift","height","listener","addEventListener","touch","h","parseInt","innerHeight","source","multiplier","boundY","update","x","y","handleScroll","repeatOften","requestAnimationFrame","change","toString","call","event","offset","offsset","nOffset","scrollY","Math","min","max","clearInterval","pause","removeEventListener","resetScreens","removeAttribute","removeChild","id","querySelector","Array","prototype","slice","parentNode","children","indexOf","start","end","delta","setInterval","parseFloat","scrollSpeed","setValues","time","Date","getTime","step","documentElement","scrollTop","pageYOffset","global","module","exports"],"mappings":"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","file":"wicket.992d7aa7.js","sourceRoot":"..","sourcesContent":["(function (global, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(['exports', 'module'], factory);\n\t} else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {\n\t\tfactory(exports, module);\n\t} else {\n\t\tvar mod = {\n\t\t\texports: {}\n\t\t};\n\t\tfactory(mod.exports, mod);\n\t\tglobal.Impetus = mod.exports;\n\t}\n})(this, function (exports, module) {\n\t'use strict';\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n\tvar stopThresholdDefault = 0.3;\n\tvar bounceDeceleration = 0.04;\n\tvar bounceAcceleration = 0.11;\n\n\tvar Impetus = function Impetus(_ref) {\n\t\tvar _ref$source = _ref.source;\n\t\tvar sourceEl = _ref$source === undefined ? document : _ref$source;\n\t\tvar updateCallback = _ref.update;\n\t\tvar _ref$multiplier = _ref.multiplier;\n\t\tvar multiplier = _ref$multiplier === undefined ? 1 : _ref$multiplier;\n\t\tvar _ref$friction = _ref.friction;\n\t\tvar friction = _ref$friction === undefined ? 0.92 : _ref$friction;\n\t\tvar initialValues = _ref.initialValues;\n\t\tvar boundX = _ref.boundX;\n\t\tvar boundY = _ref.boundY;\n\t\tvar _ref$bounce = _ref.bounce;\n\t\tvar bounce = _ref$bounce === undefined ? true : _ref$bounce;\n\n\t\t_classCallCheck(this, Impetus);\n\n\t\tvar boundXmin, boundXmax, boundYmin, boundYmax, pointerLastX, pointerLastY, pointerCurrentX, pointerCurrentY, pointerId, decVelX, decVelY;\n\t\tvar targetX = 0;\n\t\tvar targetY = 0;\n\t\tvar stopThreshold = stopThresholdDefault * multiplier;\n\t\tvar ticking = false;\n\t\tvar pointerActive = false;\n\t\tvar paused = false;\n\t\tvar decelerating = false;\n\t\tvar trackingPoints = [];\n\n\t\t/**\n   * Initialize instance\n   */\n\t\t(function init() {\n\t\t\tsourceEl = typeof sourceEl === 'string' ? document.querySelector(sourceEl) : sourceEl;\n\t\t\tif (!sourceEl) {\n\t\t\t\tthrow new Error('IMPETUS: source not found.');\n\t\t\t}\n\n\t\t\tif (!updateCallback) {\n\t\t\t\tthrow new Error('IMPETUS: update function not defined.');\n\t\t\t}\n\n\t\t\tif (initialValues) {\n\t\t\t\tif (initialValues[0]) {\n\t\t\t\t\ttargetX = initialValues[0];\n\t\t\t\t}\n\t\t\t\tif (initialValues[1]) {\n\t\t\t\t\ttargetY = initialValues[1];\n\t\t\t\t}\n\t\t\t\tcallUpdateCallback();\n\t\t\t}\n\n\t\t\t// Initialize bound values\n\t\t\tif (boundX) {\n\t\t\t\tboundXmin = boundX[0];\n\t\t\t\tboundXmax = boundX[1];\n\t\t\t}\n\t\t\tif (boundY) {\n\t\t\t\tboundYmin = boundY[0];\n\t\t\t\tboundYmax = boundY[1];\n\t\t\t}\n\n\t\t\tsourceEl.addEventListener('touchstart', onDown);\n\t\t\tsourceEl.addEventListener('mousedown', onDown);\n\t\t})();\n\n\t\t/**\n   * Disable movement processing\n   * @public\n   */\n\t\tthis.pause = function () {\n\t\t\tpointerActive = false;\n\t\t\tpaused = true;\n\t\t};\n\n\t\t/**\n   * Enable movement processing\n   * @public\n   */\n\t\tthis.resume = function () {\n\t\t\tpaused = false;\n\t\t};\n\n\t\t/**\n   * Update the current x and y values\n   * @public\n   * @param {Number} x\n   * @param {Number} y\n   */\n\t\tthis.setValues = function (x, y) {\n\t\t\tif (typeof x === 'number') {\n\t\t\t\ttargetX = x;\n\t\t\t}\n\t\t\tif (typeof y === 'number') {\n\t\t\t\ttargetY = y;\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Update the multiplier value\n   * @public\n   * @param {Number} val\n   */\n\t\tthis.setMultiplier = function (val) {\n\t\t\tmultiplier = val;\n\t\t\tstopThreshold = stopThresholdDefault * multiplier;\n\t\t};\n\n\t\t/**\n   * Executes the update function\n   */\n\t\tfunction callUpdateCallback() {\n\t\t\tupdateCallback.call(sourceEl, targetX, targetY);\n\t\t}\n\n\t\t/**\n   * Creates a custom normalized event object from touch and mouse events\n   * @param  {Event} ev\n   * @returns {Object} with x, y, and id properties\n   */\n\t\tfunction normalizeEvent(ev) {\n\t\t\tif (ev.type === 'touchmove' || ev.type === 'touchstart' || ev.type === 'touchend') {\n\t\t\t\tvar touch = ev.targetTouches[0] || ev.changedTouches[0];\n\t\t\t\treturn {\n\t\t\t\t\tx: touch.clientX,\n\t\t\t\t\ty: touch.clientY,\n\t\t\t\t\tid: touch.identifier\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// mouse events\n\t\t\t\treturn {\n\t\t\t\t\tx: ev.clientX,\n\t\t\t\t\ty: ev.clientY,\n\t\t\t\t\tid: null\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Initializes movement tracking\n   * @param  {Object} ev Normalized event\n   */\n\t\tfunction onDown(ev) {\n\t\t\tvar event = normalizeEvent(ev);\n\t\t\tif (!pointerActive && !paused) {\n\t\t\t\tpointerActive = true;\n\t\t\t\tdecelerating = false;\n\t\t\t\tpointerId = event.id;\n\n\t\t\t\tpointerLastX = pointerCurrentX = event.x;\n\t\t\t\tpointerLastY = pointerCurrentY = event.y;\n\t\t\t\ttrackingPoints = [];\n\t\t\t\taddTrackingPoint(pointerLastX, pointerLastY);\n\n\t\t\t\tdocument.addEventListener('touchmove', onMove);\n\t\t\t\tdocument.addEventListener('touchend', onUp);\n\t\t\t\tdocument.addEventListener('touchcancel', stopTracking);\n\t\t\t\tdocument.addEventListener('mousemove', onMove);\n\t\t\t\tdocument.addEventListener('mouseup', onUp);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Handles move events\n   * @param  {Object} ev Normalized event\n   */\n\t\tfunction onMove(ev) {\n\t\t\tev.preventDefault();\n\t\t\tvar event = normalizeEvent(ev);\n\n\t\t\tif (pointerActive && event.id === pointerId) {\n\t\t\t\tpointerCurrentX = event.x;\n\t\t\t\tpointerCurrentY = event.y;\n\t\t\t\taddTrackingPoint(pointerLastX, pointerLastY);\n\t\t\t\trequestTick();\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Handles up/end events\n   * @param {Object} ev Normalized event\n   */\n\t\tfunction onUp(ev) {\n\t\t\tvar event = normalizeEvent(ev);\n\n\t\t\tif (pointerActive && event.id === pointerId) {\n\t\t\t\tstopTracking();\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Stops movement tracking, starts animation\n   */\n\t\tfunction stopTracking() {\n\t\t\tpointerActive = false;\n\t\t\taddTrackingPoint(pointerLastX, pointerLastY);\n\t\t\tstartDecelAnim();\n\n\t\t\tdocument.removeEventListener('touchmove', onMove);\n\t\t\tdocument.removeEventListener('touchend', onUp);\n\t\t\tdocument.removeEventListener('touchcancel', stopTracking);\n\t\t\tdocument.removeEventListener('mouseup', onUp);\n\t\t\tdocument.removeEventListener('mousemove', onMove);\n\t\t}\n\n\t\t/**\n   * Records movement for the last 100ms\n   * @param {number} x\n   * @param {number} y [description]\n   */\n\t\tfunction addTrackingPoint(x, y) {\n\t\t\tvar time = Date.now();\n\t\t\twhile (trackingPoints.length > 0) {\n\t\t\t\tif (time - trackingPoints[0].time <= 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrackingPoints.shift();\n\t\t\t}\n\n\t\t\ttrackingPoints.push({ x: x, y: y, time: time });\n\t\t}\n\n\t\t/**\n   * Calculate new values, call update function\n   */\n\t\tfunction updateAndRender() {\n\t\t\tvar pointerChangeX = pointerCurrentX - pointerLastX;\n\t\t\tvar pointerChangeY = pointerCurrentY - pointerLastY;\n\n\t\t\ttargetX += pointerChangeX * multiplier;\n\t\t\ttargetY += pointerChangeY * multiplier;\n\n\t\t\tif (bounce) {\n\t\t\t\tvar diff = checkBounds();\n\t\t\t\tif (diff.x !== 0) {\n\t\t\t\t\ttargetX -= pointerChangeX * dragOutOfBoundsMultiplier(diff.x) * multiplier;\n\t\t\t\t}\n\t\t\t\tif (diff.y !== 0) {\n\t\t\t\t\ttargetY -= pointerChangeY * dragOutOfBoundsMultiplier(diff.y) * multiplier;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcheckBounds(true);\n\t\t\t}\n\n\t\t\tcallUpdateCallback();\n\n\t\t\tpointerLastX = pointerCurrentX;\n\t\t\tpointerLastY = pointerCurrentY;\n\t\t\tticking = false;\n\t\t}\n\n\t\t/**\n   * Returns a value from around 0.5 to 1, based on distance\n   * @param {Number} val\n   */\n\t\tfunction dragOutOfBoundsMultiplier(val) {\n\t\t\treturn 0.000005 * Math.pow(val, 2) + 0.0001 * val + 0.55;\n\t\t}\n\n\t\t/**\n   * prevents animating faster than current framerate\n   */\n\t\tfunction requestTick() {\n\t\t\tif (!ticking) {\n\t\t\t\trequestAnimFrame(updateAndRender);\n\t\t\t}\n\t\t\tticking = true;\n\t\t}\n\n\t\t/**\n   * Determine position relative to bounds\n   * @param {Boolean} restrict Whether to restrict target to bounds\n   */\n\t\tfunction checkBounds(restrict) {\n\t\t\tvar xDiff = 0;\n\t\t\tvar yDiff = 0;\n\n\t\t\tif (boundXmin !== undefined && targetX < boundXmin) {\n\t\t\t\txDiff = boundXmin - targetX;\n\t\t\t} else if (boundXmax !== undefined && targetX > boundXmax) {\n\t\t\t\txDiff = boundXmax - targetX;\n\t\t\t}\n\n\t\t\tif (boundYmin !== undefined && targetY < boundYmin) {\n\t\t\t\tyDiff = boundYmin - targetY;\n\t\t\t} else if (boundYmax !== undefined && targetY > boundYmax) {\n\t\t\t\tyDiff = boundYmax - targetY;\n\t\t\t}\n\n\t\t\tif (restrict) {\n\t\t\t\tif (xDiff !== 0) {\n\t\t\t\t\ttargetX = xDiff > 0 ? boundXmin : boundXmax;\n\t\t\t\t}\n\t\t\t\tif (yDiff !== 0) {\n\t\t\t\t\ttargetY = yDiff > 0 ? boundYmin : boundYmax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: xDiff,\n\t\t\t\ty: yDiff,\n\t\t\t\tinBounds: xDiff === 0 && yDiff === 0\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Initialize animation of values coming to a stop\n   */\n\t\tfunction startDecelAnim() {\n\t\t\tvar firstPoint = trackingPoints[0];\n\t\t\tvar lastPoint = trackingPoints[trackingPoints.length - 1];\n\n\t\t\tvar xOffset = lastPoint.x - firstPoint.x;\n\t\t\tvar yOffset = lastPoint.y - firstPoint.y;\n\t\t\tvar timeOffset = lastPoint.time - firstPoint.time;\n\n\t\t\tvar D = timeOffset / 15 / multiplier;\n\n\t\t\tdecVelX = xOffset / D || 0; // prevent NaN\n\t\t\tdecVelY = yOffset / D || 0;\n\n\t\t\tvar diff = checkBounds();\n\n\t\t\tif (Math.abs(decVelX) > 1 || Math.abs(decVelY) > 1 || !diff.inBounds) {\n\t\t\t\tdecelerating = true;\n\t\t\t\trequestAnimFrame(stepDecelAnim);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Animates values slowing down\n   */\n\t\tfunction stepDecelAnim() {\n\t\t\tif (!decelerating) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdecVelX *= friction;\n\t\t\tdecVelY *= friction;\n\n\t\t\ttargetX += decVelX;\n\t\t\ttargetY += decVelY;\n\n\t\t\tvar diff = checkBounds();\n\n\t\t\tif (Math.abs(decVelX) > stopThreshold || Math.abs(decVelY) > stopThreshold || !diff.inBounds) {\n\n\t\t\t\tif (bounce) {\n\t\t\t\t\tvar reboundAdjust = 2.5;\n\n\t\t\t\t\tif (diff.x !== 0) {\n\t\t\t\t\t\tif (diff.x * decVelX <= 0) {\n\t\t\t\t\t\t\tdecVelX += diff.x * bounceDeceleration;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar adjust = diff.x > 0 ? reboundAdjust : -reboundAdjust;\n\t\t\t\t\t\t\tdecVelX = (diff.x + adjust) * bounceAcceleration;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.y !== 0) {\n\t\t\t\t\t\tif (diff.y * decVelY <= 0) {\n\t\t\t\t\t\t\tdecVelY += diff.y * bounceDeceleration;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar adjust = diff.y > 0 ? reboundAdjust : -reboundAdjust;\n\t\t\t\t\t\t\tdecVelY = (diff.y + adjust) * bounceAcceleration;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (diff.x !== 0) {\n\t\t\t\t\t\tif (diff.x > 0) {\n\t\t\t\t\t\t\ttargetX = boundXmin;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetX = boundXmax;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdecVelX = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.y !== 0) {\n\t\t\t\t\t\tif (diff.y > 0) {\n\t\t\t\t\t\t\ttargetY = boundYmin;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetY = boundYmax;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdecVelY = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallUpdateCallback();\n\n\t\t\t\trequestAnimFrame(stepDecelAnim);\n\t\t\t} else {\n\t\t\t\tdecelerating = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * @see http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n  */\n\t;\n\n\tmodule.exports = Impetus;\n\tvar requestAnimFrame = (function () {\n\t\treturn window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {\n\t\t\twindow.setTimeout(callback, 1000 / 60);\n\t\t};\n\t})();\n});\n","const Impetus = require('Impetus')\n\nconst log = (msg) => {\n    if (window.console && window.console.error) {\n        console.error (msg)\n    }\n}\n\nconst isTouchDevice = () => {\n    return (('ontouchstart' in window)\n        || (navigator.MaxTouchPoints > 0)\n        || (navigator.msMaxTouchPoints > 0))\n}\n\nconst forceRepaint = hatch => {\n    // force element repaint on touch devices\n    if (isTouchDevice() && !hatch.dataset.haspaint) {\n        hatch.style.display = 'none'\n        hatch.offsetHeight\n        hatch.style.display = ''\n        hatch.dataset.haspaint = 'yes'\n    }\n}\n\nconst translateY = (obj, val) => {\n    obj.style['transform'] = `translate3d(0px,${val}px,0px)`\n    obj.style['-ms-transform'] = `translate3d(0px,${val}px,0px)`\n    obj.style['-webkit-transform'] = `translate3d(0px,${val}px,0px)`\n}\n\nclass Wicket {\n    constructor(elm, options) {\n        this.hatches = document.querySelectorAll(elm)\n        this.impetus = null\n        this.scrollPoints = []\n        this.interval = false\n        this.isInit = false\n        this.scroller = null\n        this.index = 0\n        this.scrollOffset = 0\n        this.lastScrollTop = 0\n\n        // Defaults\n        const defaults = {\n            'touch': true,\n            'change': null\n        }\n\n        // Create options by extending defaults with the passed in arguments\n        if (arguments[1] && typeof arguments[1] === 'object') {\n            this.options = { ...defaults, ...arguments[1] }\n        } else {\n            this.options = defaults\n        }\n\n        try {\n            if (this.hatches.length < 1) throw 'No matching elements found'\n            this.init()\n        }\n        catch (err) {\n            log(err)\n        }\n    }\n\n    init() {\n        if (!this.isInit) {\n            this.createScroller()\n            this.fixHatches()\n            this.calcScrollPoints()\n            this.bindListeners()\n            this.bindEvents()\n            this.callChangeCallback()\n\n            if (this.impetus) {\n                this.impetus.resume()\n            }\n\n            this.isInit = true\n        }\n    }\n\n    refresh() {\n        this.init()\n    }\n\n    createScroller() {\n        this.scroller = document.createElement('div')\n        this.scroller.style.position = 'absolute'\n        this.scroller.style.width = '1px'\n        document.body.appendChild(this.scroller)\n    }\n\n    fixHatches() {\n        for (let i=0, len=this.hatches.length; i<len; i++) {\n            this.hatches[i].style.position = 'fixed'\n            this.hatches[i].style.zIndex = this.hatches.length - i\n        }\n    }\n\n    calcScrollPoints() {\n        this.scrollPoints = []\n        for (let i=0, len=this.hatches.length; i<len; i++) {\n            const oHeight = this.hatches[i].offsetHeight\n            const nHeight = (i>0) ? (oHeight + this.scrollPoints[i-1]) : oHeight\n            this.scrollPoints.push(nHeight)\n        }\n        this.scrollPoints.unshift(0)\n        this.scroller.style.height = `${this.scrollPoints[this.scrollPoints.length-1]}px`\n    }\n\n    bindListeners() {\n        this.listener = () => {\n            this.calcScrollPoints()\n        }\n\n        window.addEventListener('resize', this.listener)\n        window.addEventListener('orientationchange', this.listener)\n    }\n\n    bindEvents() {\n        if (!isTouchDevice() && !this.interval) {\n            const repeatOften = () => {\n                this.handleScroll()\n                this.interval = requestAnimationFrame(repeatOften)\n            }\n            repeatOften()\n        } else {\n            if (this.options.touch === true) {\n                // calculate outer bounds\n                const h = (parseInt(this.scroller.style.height) - window.innerHeight) * -1\n                this.impetus = new Impetus({\n                    source: document.body,\n                    multiplier: 1.5,\n                    boundY: [h, 0],\n                    update: (x, y) => {\n                        this.handleScroll('touch', y)\n                    }\n                })\n            }\n        }\n    }\n\n    callChangeCallback() {\n        const getType = {}\n        if (this.options.change && getType.toString.call(this.options.change) === '[object Function]') {\n            this.options.change.call(this, this.index)\n        }\n    }\n\n    handleScroll(event, offset) {\n        // incoming offset should be negative\n        offsset = (offset>=0) ? -0.001 : offset\n        const nOffset = offset || window.scrollY * -1\n        const hatch = this.hatches[this.index]\n        const scrollOffset = (nOffset + this.scrollPoints[this.index])\n        const oIndex = this.index\n        translateY(hatch, scrollOffset)\n        \n        // keep track of the current scrollOffset\n        this.scrollOffset = nOffset\n        forceRepaint(hatch)\n        \n        if ((nOffset*-1)>this.scrollPoints[this.index+1]) {\n            this.index++\n            this.index = Math.min(this.index, this.hatches.length-1)\n            this.callChangeCallback()\n        }\n\n        if ((nOffset*-1) < this.scrollPoints[this.index]) {\n            // make all the panels hard snap to the top, except the first one, which may bounce\n            if (this.index > 0) {\n                translateY(hatch, 0)\n            }\n\n            this.index--\n            this.index = Math.max(0, this.index)\n            this.callChangeCallback()\n        }\n    }\n\n    destroy() {\n        if (this.isInit) {\n            clearInterval(this.interval)\n            this.interval = false\n            this.isInit = false\n\n            if (this.impetus) {\n                this.impetus.pause()\n            }\n\n            window.removeEventListener('resize', this.listener)\n            window.removeEventListener('scroll', this.listener)\n            this.resetScreens()\n        }\n    }\n\n    resetScreens() {\n        for (let i=0, len=this.hatches.length; i<len; i++) {\n            this.hatches[i].removeAttribute('style')\n        }\n        document.body.removeChild(this.scroller)\n    }\n\n    scrollTo(id) {\n        let interval\n        const elm = document.querySelector(id)\n        const nodeList = Array.prototype.slice.call(elm.parentNode.children)\n        const index = nodeList.indexOf(elm)\n\n        if (interval) clearInterval(interval)\n\n        this.index = index\n\n        const start = this.scrollOffset\n        const end = this.scrollPoints[index]*-1\n        const delta = start\n        const scrollSpeed = 55\n\n        if (!isTouchDevice()) {\n            const time = 350\n            const start = new Date().getTime()\n\n            interval = setInterval(() => {\n                const step = Math.min(1, (new Date().getTime() - start) / time)\n                document.documentElement.scrollTop = window.pageYOffset + step * ((end * -1) - window.pageYOffset)\n                \n                if (step == 1) clearInterval(interval)\n            }, scrollSpeed)\n\n            document.documentElement.scrollTop = window.pageYOffset\n        } else {\n            interval = setInterval(() => {\n                if (start < end) {\n                    if (delta >= end) clearInterval(interval)\n                    delta = parseFloat(Math.min(delta += scrollSpeed, end)) + 0.001\n                } else {\n                    if (delta <= end) clearInterval(interval)\n                    delta = parseFloat(Math.max(delta -= scrollSpeed, end)) - 0.001\n                }\n                this.handleScroll('touch', delta)\n                if (this.impetus) {\n                    this.impetus.setValues(0, end)\n                }\n            }, 10)\n        }\n    }\n} \n\nglobal.Wicket = module.exports = Wicket"]}